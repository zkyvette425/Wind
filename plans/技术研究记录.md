# 技术研究记录

## 🎯 使用指南
**查阅优先级**：
1. **优先查阅本文件** - 包含最新的实际解决方案和最佳实践
2. **其次使用Context7** - 获取官方文档参考
3. **最后查阅源码** - GitHub Issues/官方源码

**记录格式**：每个技术问题包含【问题背景】【解决方案】【关键发现】【避坑指南】

---

## 📚 技术研究案例库

### 🚨 案例1: Orleans 9.2.1 MessagePack序列化配置冲突

**研究日期**: 2025-08-13 (北京时间)  
**解决状态**: ✅ 已解决  
**影响范围**: Orleans Silo启动失败 → 生产环境和测试环境正常运行

#### 【问题背景】
- Orleans Silo启动时报错：`Found unserializable or uncopyable types`
- Context7文档建议同时使用Orleans原生序列化和MessagePack序列化
- 实际配置导致序列化器冲突，Silo无法启动

#### 【错误配置方式】(来自Context7文档)
```csharp
// ❌ 错误：混合使用两种序列化器导致冲突
[GenerateSerializer]     // Orleans原生序列化
[MessagePackObject]      // MessagePack序列化
public class PlayerState
{
    [Id(0)]             // Orleans序列化ID
    [Key(0)]            // MessagePack序列化Key
    public string PlayerId { get; set; }
}
```

#### 【正确解决方案】
```csharp
// ✅ 正确：仅使用MessagePack序列化
[MessagePackObject]
public class PlayerState 
{
    [MPKey(0)]  // 使用alias避免命名冲突
    public string PlayerId { get; set; }
}

// using alias解决命名空间冲突
using MPKey = MessagePack.KeyAttribute;

// Orleans Silo配置 
builder.Host.UseOrleans(siloBuilder =>
{
    siloBuilder
        .UseLocalhostClustering()
        .AddMemoryGrainStorage("PlayerStorage");
});

// 在Services层配置MessagePack序列化器
builder.Services.AddSerializer(serializerBuilder => 
    serializerBuilder.AddMessagePackSerializer());
```

#### 【关键发现】
1. **序列化器互斥**: Orleans 9.2.1中，原生序列化和MessagePack不能同时使用
2. **配置位置**: MessagePack序列化器应在`Services`层配置，不是在`SiloBuilder`层
3. **命名空间冲突**: `System.ComponentModel.DataAnnotations.KeyAttribute` vs `MessagePack.KeyAttribute`
4. **包依赖**: 需要`Microsoft.Orleans.Serialization.MessagePack`包

#### 【避坑指南】
- ⚠️ **不要**同时使用`[GenerateSerializer]`和`[MessagePackObject]`
- ⚠️ **不要**在SiloBuilder上直接调用`AddSerializer`
- ✅ **使用**alias解决Key属性冲突：`using MPKey = MessagePack.KeyAttribute`
- ✅ **确保**测试环境和生产环境配置一致
- ✅ **优先**查阅本记录，Context7的Orleans文档可能包含过时的混合配置示例

### 🔍 案例2: Orleans 9.2.1 MemoryPack序列化可行性评估

**研究日期**: 2025-08-13 (北京时间)  
**解决状态**: 📊 已评估完成  
**影响范围**: 技术选型决策 - MessagePack vs MemoryPack

#### 【问题背景】
- MemoryPack性能比MessagePack快2-5倍，考虑技术升级
- 用户询问为什么不使用更快的MemoryPack序列化器
- 需要评估Orleans对MemoryPack的支持情况

#### 【研究发现】
**Context7查询结果**: Orleans 9.2.1官方支持的序列化器
- ✅ MessagePack (`Microsoft.Orleans.Serialization.MessagePack`)
- ✅ System.Text.Json (`Microsoft.Orleans.Serialization.SystemTextJson`)
- ✅ Newtonsoft.Json (`Microsoft.Orleans.Serialization.NewtonsoftJson`)
- ✅ Protobuf (`Microsoft.Orleans.Serialization.Protobuf`)
- ✅ F# 原生支持 (`Microsoft.Orleans.Serialization.FSharp`)
- ❌ **无MemoryPack官方支持**

**WebSearch补充结果**:
- MemoryPack基准测试显示比MessagePack快2-5倍
- Orleans提供可扩展序列化框架，理论上可自定义集成
- 但需要社区驱动开发，无官方支持计划

#### 【技术评估】
**MemoryPack优势**:
- 🚀 **性能**: 比MessagePack快2-5倍
- 🎯 **C#优化**: 专为.NET 7+和C# 11优化
- 💾 **内存效率**: 零拷贝序列化
- 🔧 **现代化**: 使用增量源生成器

**当前选择MessagePack的原因**:
- ✅ **官方支持**: Orleans官方维护的集成包
- ✅ **稳定性**: 成熟的生产环境验证
- ✅ **生态兼容**: 与Unity、其他语言客户端兼容
- ✅ **维护成本**: 无需自维护集成代码

#### 【技术决策建议】
**短期**: 继续使用MessagePack
- 风险低，稳定可靠
- 性能已经比JSON序列化快3-5倍
- 官方支持和维护

**长期**: 关注MemoryPack发展
- 监控Orleans社区对MemoryPack的集成需求
- 评估自定义序列化器开发成本
- 在v2.0架构升级时重新评估

#### 【避坑指南】
- ⚠️ **不建议**在生产环境中使用自定义MemoryPack集成
- ⚠️ **性能优化**应先优化业务逻辑，序列化通常不是瓶颈
- ✅ **基准测试**如需验证性能影响，应建立完整的基准测试框架
- ✅ **技术监控**定期检查Orleans社区对MemoryPack的官方支持进展

---

## Orleans .NET 9 研究记录

### 研究日期: 2025-08-11 (北京时间)
### 研究方式: WebSearch (Context7暂时无法访问)
### 研究来源: Microsoft Learn官方文档

## Orleans 9.2.1 + MessagePack序列化研究记录

### 研究日期: 2025-08-12 (北京时间)
### 研究方式: Task Agent + Context7查询
### 研究来源: Orleans 9.2.1官方文档 + MessagePack集成指南

#### 核心发现

##### 1. Orleans 9.2.1序列化配置最佳实践
```csharp
// 正确的Orleans + MessagePack序列化配置
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Orleans.Serialization;

var builder = Host.CreateApplicationBuilder(args)
    .UseOrleans(siloBuilder =>
    {
        siloBuilder
            .UseLocalhostClustering()
            // 添加MessagePack作为Orleans的序列化器
            .AddSerializer(serializerBuilder => serializerBuilder.AddMessagePackSerializer());
    });
```

##### 2. 双重序列化支持的类型定义
```csharp
// 同时支持Orleans和MessagePack的序列化
[GenerateSerializer]  // Orleans序列化支持
[MessagePackObject]   // MessagePack序列化支持
public class PlayerData
{
    [Id(0)]  // Orleans序列化ID
    [Key(0)] // MessagePack序列化Key
    public string PlayerId { get; set; } = string.Empty;
    
    [Id(1)]
    [Key(1)]
    public string PlayerName { get; set; } = string.Empty;
}
```

##### 3. 关键技术要点
- Orleans 9.2.1需要使用`Microsoft.Orleans.Serialization.MessagePack`包
- 字段ID一致性：`[Id(n)]`和`[Key(n)]`使用相同数字确保序列化兼容
- 必须在Shared项目中添加`Microsoft.Orleans.Serialization.Abstractions`包引用
- 需要构建项目以生成Orleans序列化器代码

##### 4. 序列化性能对比
- MessagePack比JSON序列化性能提升约3-5倍
- 数据体积减少约30-50%
- 支持版本兼容的序列化格式演进

---

#### 核心发现

##### 1. Orleans现代化宿主模式 (.NET 9兼容)
```csharp
// Program.cs - 现代化的Orleans Silo宿主配置
using Microsoft.Extensions.Hosting;

await Host.CreateDefaultBuilder(args)
    .UseOrleans(siloBuilder => 
    {
        siloBuilder.UseLocalhostClustering(); // 本地开发环境
        siloBuilder.ConfigureEndpoints(siloPort: 11111, gatewayPort: 30000);
    })
    .RunConsoleAsync();
```

##### 2. 生产环境配置示例
```csharp
using IHost host = Host.CreateDefaultBuilder(args)
    .UseOrleans(builder => 
    {
        builder.UseAzureStorageClustering(options => 
            options.ConfigureTableServiceClient(connectionString));
    })
    .UseConsoleLifetime()
    .Build();
```

##### 3. 关键配置要素
- **ClusterId**: 集群唯一标识，同一集群内所有Silo和Client可以直接通信
- **ServiceId**: 应用唯一标识，用于持久化提供程序，部署过程中应保持稳定
- **端口配置**: 
  - 默认Silo间通信端口: 11111
  - 默认Client-Silo通信端口: 30000
  - 可通过ConfigureEndpoints自定义

##### 4. 必需的NuGet包
- **开发Silo**: `Microsoft.Orleans.Server` + `Microsoft.Extensions.Hosting`
- **架构**: 遵循.NET现代化配置模式和依赖注入

---

## MagicOnion 研究记录

### 研究日期: 2025-08-11 (北京时间)
### 研究方式: WebSearch + GitHub官方文档
### 最新版本: v7.0.6 (2024活跃维护)

#### 核心发现

##### 1. MagicOnion特性
- **统一框架**: 同时支持RPC API和实时通信(类似SignalR)
- **基于gRPC**: HTTP/2二进制传输，高性能
- **MessagePack序列化**: 最快的C#二进制序列化器
- **代码共享**: C#接口作为协议架构，无需.proto文件
- **Unity支持**: Unity 2021.3.0f1(LTS)以上版本

##### 2. 服务端配置 (ASP.NET Core)
```csharp
// Program.cs - MagicOnion服务端设置
using MagicOnion;
using MagicOnion.Server;

var builder = WebApplication.CreateBuilder(args);
builder.Services.AddMagicOnion(); // 添加MagicOnion服务

var app = builder.Build();
app.MapMagicOnionService(); // 映射MagicOnion服务
```

##### 3. 服务接口定义
```csharp
// 共享接口定义 (Server + Client)
using MagicOnion;

public interface IMyFirstService : IService<IMyFirstService>
{
    // 返回类型必须是UnaryResult<T>或UnaryResult
    UnaryResult<int> SumAsync(int x, int y);
}
```

##### 4. 服务实现
```csharp
// 服务端实现
using MagicOnion.Server;

public class MyFirstService : ServiceBase<IMyFirstService>, IMyFirstService
{
    public async UnaryResult<int> SumAsync(int x, int y)
    {
        Console.WriteLine($"Received:{x}, {y}");
        return x + y;
    }
}
```

##### 5. 客户端使用
```csharp
// 客户端调用
using Grpc.Net.Client;
using MagicOnion.Client;

var channel = GrpcChannel.ForAddress("https://localhost:5001");
var client = MagicOnionClient.Create<IMyFirstService>(channel);
var result = await client.SumAsync(123, 456);
```

##### 6. Unity特殊考虑
- **MessagePack单独安装**: MagicOnion包不包含MessagePack，需要单独安装
- **HTTP客户端**: 推荐使用YetAnotherHttpHandler替代过时的C-core库
- **StreamingHub**: 支持全类型化的实时通信，类似SignalR但性能更高

##### 7. 架构优势
- **性能**: 基于gRPC + MessagePack，比传统SignalR快数倍
- **开发效率**: C#接口共享，无需维护额外的协议定义文件
- **游戏专用**: 专门为Unity游戏场景优化
- **商业验证**: 已在多个商业游戏中使用

#### 技术决策验证

基于研究结果，我们之前的技术选型完全正确：

1. **Orleans 9.2.1**: 完全支持.NET 9，使用现代化宿主模式
2. **MagicOnion 7.0.6**: 活跃维护，专为游戏优化，性能卓越
3. **架构兼容性**: 两者都遵循.NET现代化开发模式，可完美集成

#### 后续行动项
1. **Orleans**: 使用Microsoft.Orleans.Server + 现代化配置
2. **MagicOnion**: 集成到Orleans宿主中，共享依赖注入容器
3. **MessagePack**: 单独安装，配置序列化选项
4. **开发环境**: 本地集群配置，生产环境使用云存储集群

---

### 🚨 案例2: Orleans 9.2.1 Redis存储配置API兼容性问题

**研究日期**: 2025-08-15 (北京时间)  
**解决状态**: ✅ 已解决  
**影响范围**: Orleans Redis持久化存储配置失败 → 正确的配置语法应用

#### 【问题背景】
- Orleans 9.2.1官方文档中的RedisStorageOptions配置API在实际版本中不存在
- Context7查阅的RedisStorageOptions属性（ConnectionString、Database、UseJson等）不可用
- 编译时报错：CS1061 未包含 ConnectionString、Database 等属性的定义
- 文档与实际API版本不匹配，导致按文档配置完全无法工作

#### 【错误配置方式】(来自官方文档)
```csharp
// ❌ 错误：Orleans 9.2.1中这些属性不存在
siloBuilder.AddRedisGrainStorage("PlayerStorage", options =>
{
    options.ConnectionString = "localhost:6379";  // 不存在
    options.Database = 0;                         // 不存在  
    options.UseJson = false;                      // 不存在
    options.KeyPrefix = "player";                 // 不存在
});
```

#### 【用户提供的正确解决方案】
```csharp
// ✅ 正确：Orleans 9.2.1实际可用的配置方式
siloBuilder.AddRedisGrainStorage(
    name: "PlayerStorage",
    options =>
    {
        // 使用StackExchange.Redis.ConfigurationOptions
        options.ConfigurationOptions = ConfigurationOptions.Parse("localhost:6379,password=windgame123");
        
        // 自定义存储键生成逻辑
        options.GetStorageKey = (type, id) => $"player:{type}-{id}";
    });

// 多数据库配置示例
siloBuilder.AddRedisGrainStorage(
    name: "RoomStorage", 
    options =>
    {
        var redisConfig = ConfigurationOptions.Parse("localhost:6379,password=windgame123");
        redisConfig.DefaultDatabase = 1;  // 使用数据库1
        options.ConfigurationOptions = redisConfig;
        options.GetStorageKey = (type, id) => $"room:{type}-{id}";
    });
```

#### 【关键发现】
1. **API变更**: Orleans 9.2.1使用StackExchange.Redis.ConfigurationOptions代替简单字符串配置
2. **连接配置**: 通过ConfigurationOptions.Parse()方法解析完整连接字符串，支持密码等参数
3. **数据库选择**: 通过ConfigurationOptions.DefaultDatabase属性设置Redis数据库
4. **存储键自定义**: 必须通过GetStorageKey委托自定义键生成策略，无内置KeyPrefix
5. **序列化器**: 可选配置GrainStorageSerializer，但用户建议暂时省略复杂配置

#### 【避坑指南】
1. **API兼容性**: Orleans版本升级时重点关注存储提供程序Breaking Changes
2. **文档时效性**: 官方文档可能滞后于实际API版本，需多方验证
3. **技术困难处理**: 遇到API兼容性问题时立即寻求有经验人员指导，不要自行简化
4. **配置验证**: Redis存储配置后必须实际测试连接和存储功能
5. **密码认证**: 生产Redis通常需要密码认证，连接字符串中必须包含密码参数

#### 【工作方式教训】
- **困难汇报机制**: 遇到技术困难应立即详细汇报，而非尝试简化绕过
- **用户指导价值**: 用户提供的解决方案准确有效，证明了寻求指导的重要性
- **协作解决**: 技术问题通过协作解决比单兵作战更高效

#### 【成功应用结果】
- Redis存储配置编译通过
- 支持密码认证连接
- 实现了数据库分离（database 0, 1, 2）
- 建立了有意义的存储键前缀（player:, room:, match:）
- 为后续Orleans Grain持久化奠定了正确基础

---

*本记录将在项目进展过程中持续更新，记录新的技术发现和实践经验。*