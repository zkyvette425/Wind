# Unity客户端技术决策记录

> **文档类型**: 技术决策记录(ADR)导航  
> **创建时间**: 2025-08-30 (北京时间)  
> **决策原则**: 基于充分调研的技术决策  

---

## 📋 技术决策记录概述

本目录记录Wind Unity客户端开发过程中的所有重要技术决策，采用架构决策记录(Architecture Decision Records, ADR)格式，确保决策的透明性和可追溯性。

### ADR格式说明
每个技术决策记录包含：
- **背景**: 决策产生的背景和原因
- **决策**: 具体的技术选择和方案
- **状态**: 决策的当前状态（提议/接受/废弃/替换）
- **后果**: 决策的影响和权衡

---

## 🏗️ 核心架构决策

### ADR-001: 统一包+智能适配策略
**状态**: ✅ 已接受  
**决策日期**: 2025-08-30  
**决策**: 采用单一com.wind.core包配合智能环境检测，而非多包分离策略

**背景**: 
- 用户在包选择时面临困难（单机版/网络版/热更新版）
- 需要准确的用户统计和使用情况分析
- 希望提供平滑的功能升级体验

**技术方案**:
```csharp
// 智能适配核心机制
public static WindCapabilities Detect()
{
    var caps = new WindCapabilities();
    caps.HasNetworkSupport = HasAssembly("MagicOnion.Client");
    caps.HasHotUpdateSupport = HasAssembly("HybridCLR.Runtime");
    return caps;
}
```

**影响**:
- ➕ 零用户选择成本，自动适配环境
- ➕ 精确的功能使用统计
- ➕ 平滑的功能推广路径
- ➖ 包体积稍大，包含未使用功能代码

### ADR-002: 自研DI容器技术选择
**状态**: ✅ 已接受  
**决策日期**: 2025-08-30  
**决策**: 完全自研DI容器，而非使用VContainer或Unity原生方案

**背景**:
- 现有DI容器无法完美契合Wind框架需求
- 需要与HybridCLR热更新深度集成
- 要求零反射、零GC的极致性能

**技术特征**:
- **零反射**: 编译时生成依赖注入代码
- **零GC**: 运行时无内存分配
- **热更新兼容**: 完整支持AOT/Hotfix分层
- **循环依赖检测**: 编译时检查依赖关系

**影响**:
- ➕ 极致性能，初始化<100ms
- ➕ 完美热更新集成
- ➕ 完全控制技术演进
- ➖ 开发复杂度高，需要深度Unity知识

### ADR-003: HybridCLR vs ILRuntime vs Lua
**状态**: ✅ 已接受  
**决策日期**: 2025-08-30  
**决策**: 选择HybridCLR作为热更新解决方案

**比较分析**:
| 方案 | 性能 | C#支持度 | Unity兼容性 | 维护成本 |
|------|------|----------|-------------|----------|
| HybridCLR | 95% | 100% | 100% | 低 |
| ILRuntime | 70% | 90% | 90% | 中 |
| Lua | 60% | 0% | 80% | 高 |

**决策理由**:
- 近原生性能，损失<5%
- 完整C#语言支持，包括泛型和反射
- Unity官方支持，兼容性最好
- 统一的开发体验

### ADR-004: 资源管理系统自研 vs YooAsset
**状态**: ✅ 已接受  
**决策日期**: 2025-08-30  
**决策**: 借鉴YooAsset设计思想，完全自研实现

**决策理由**:
- **定制需求**: 需要与自研DI容器深度集成
- **包体系一致性**: 与com.wind.*包架构保持一致
- **性能优化**: 针对Wind框架特定场景优化
- **维护控制**: 完全控制代码演进和bug修复

**借鉴特性**:
- 可寻址资源加载机制
- 引用计数内存管理
- 版本控制和增量更新
- 异步加载和缓存策略

---

## 📦 包架构决策

### ADR-005: 5层29包架构设计
**状态**: ✅ 已接受  
**决策日期**: 2025-08-30  
**决策**: 采用5层29包的分层架构设计

**架构层次**:
```
Layer 0: 基础设施层 (4包) - core, serilog, config, packagemanager
Layer 1: 框架服务层 (5包) - network, hotfix, assets, storage, localserver  
Layer 2: 游戏系统层 (5包) - ui, input, audio, effects, scene
Layer 3: 业务模块层 (4包) - rts, moba, rpg, simulation
Layer 4-5: 工具服务层 (11包) - 开发和企业工具
```

**设计原则**:
- **单一职责**: 每个包只负责特定功能领域
- **依赖方向**: 只能依赖下层包，不能循环依赖
- **可选组合**: 用户可以按需选择包组合
- **版本独立**: 每个包独立版本管理

### ADR-006: Unity Package Manager vs 自建分发
**状态**: ✅ 已接受  
**决策日期**: 2025-08-30  
**决策**: 基于Unity Package Manager + 私有Registry的分发策略

**技术方案**:
- **私有Registry**: 基于npm兼容的包注册服务
- **GitHub PAT认证**: 精确的权限控制机制
- **Scoped Registry**: Unity原生支持的私有包管理
- **包管理器UI**: 自定义Unity编辑器扩展

**权限控制**:
```toml
# ~/.upmconfig.toml
[npmAuth."https://npm.wind.com"]
token = "ghp_企业PAT令牌"
email = "developer@company.com"
alwaysAuth = true
```

---

## 🔧 技术集成决策

### ADR-007: MagicOnion vs gRPC vs REST API
**状态**: ✅ 已接受  
**决策日期**: 2025-08-30  
**决策**: 选择MagicOnion作为客户端网络通信方案

**决策理由**:
- **类型安全**: 强类型的API定义，编译时检查
- **高性能**: 基于gRPC，使用MessagePack序列化
- **Unity优化**: 专为Unity设计的网络框架
- **服务端兼容**: 与Wind服务端完美集成

**技术特征**:
- Unary API用于请求-响应模式
- StreamingHub用于实时双向通信  
- 自动代码生成，减少手工编码错误
- 内置负载均衡和错误处理

### ADR-008: MessagePack vs JSON vs ProtoBuf
**状态**: ✅ 已接受  
**决策日期**: 2025-08-30  
**决策**: 统一使用MessagePack作为序列化方案

**性能对比**:
| 方案 | 序列化速度 | 反序列化速度 | 大小 | 可读性 |
|------|------------|--------------|------|--------|
| MessagePack | 100% | 100% | 100% | 低 |
| JSON | 60% | 70% | 150% | 高 |
| ProtoBuf | 90% | 95% | 90% | 低 |

**选择理由**:
- 最佳的性能表现
- 与MagicOnion完美集成
- C#原生支持，Unity兼容性好
- 支持动态类型，灵活性高

---

## 🎯 用户体验决策

### ADR-009: 三场景用户体验设计
**状态**: ✅ 已接受  
**决策日期**: 2025-08-30  
**决策**: 设计免费体验/企业授权/单机开发三种用户场景

**场景划分**:
1. **免费体验**: 无需鉴权，基础功能，GitHub公开获取
2. **企业授权**: PAT鉴权，完整功能，私有包访问
3. **单机开发**: 完全离线，无网络依赖，本地功能完整

**渐进式复杂度**:
- 5分钟: Hello World快速体验
- 30分钟: 基础功能演示
- 2小时: 完整功能掌握
- 进阶: 自定义包开发

### ADR-010: 中英文双语文档策略
**状态**: ✅ 已接受  
**决策日期**: 2025-08-30  
**决策**: 优先中文文档，逐步支持英文国际化

**实施策略**:
- **Phase 1**: 完整中文文档体系
- **Phase 2**: 核心文档英文翻译
- **Phase 3**: 完整双语文档系统
- **Phase 4**: 多语言社区建设

---

## ⚡ 性能和质量决策

### ADR-011: 性能基准设定
**状态**: ✅ 已接受  
**决策日期**: 2025-08-30  
**决策**: 制定严格的性能基准要求

**性能目标**:
- **DI容器初始化**: <100ms (目标<50ms)
- **资源加载延迟**: <50ms小型，<200ms大型
- **热更新应用**: <200ms (目标<100ms) 
- **内存使用效率**: >90%
- **包安装时间**: <30s普通包，<2min大型包

**监控机制**:
- 自动化性能基准测试
- 持续集成中的性能回归检测
- 生产环境性能监控
- 用户体验数据收集

### ADR-012: 质量保证标准
**状态**: ✅ 已接受  
**决策日期**: 2025-08-30  
**决策**: 建立多层质量保证体系

**质量标准**:
- **代码覆盖率**: 核心功能>85%，API接口100%
- **文档完整度**: 每个功能都有完整文档和示例
- **兼容性**: Unity 2022.3+全版本支持
- **平台支持**: Windows/Mac/Android/iOS全覆盖

---

## 🔄 决策状态管理

### 决策状态定义
- **🟡 提议中**: 决策正在讨论和评估
- **✅ 已接受**: 决策已确定并开始实施
- **❌ 已拒绝**: 决策被拒绝，记录原因
- **🔄 已替换**: 决策被新决策替换
- **⏸️ 已暂停**: 决策暂时停止执行

### 决策修改流程
1. **提出修改**: 说明修改原因和新方案
2. **影响评估**: 评估修改对现有系统的影响
3. **团队讨论**: 团队充分讨论修改的必要性
4. **决策确认**: 确认修改并更新相关文档
5. **实施变更**: 按照新决策调整实现

---

## 📞 决策支持

### 决策制定原则
- **数据驱动**: 基于充分的技术调研和数据分析
- **用户优先**: 优先考虑用户体验和价值
- **技术领先**: 选择技术先进且稳定的方案
- **可维护性**: 考虑长期维护和演进需求

### 决策质量保证
- **同行评议**: 重要决策需要多人评审
- **原型验证**: 关键技术选择需要原型验证
- **用户验证**: 用户体验相关决策需要用户验证
- **持续评估**: 定期评估决策的有效性

---

**📝 决策维护**: 技术决策记录持续维护，确保决策的可追溯性和透明性。重大决策变更需要经过正式的评估和讨论流程。

**🔗 相关文档**: 
- [Unity客户端纲领](../governance/unity-纲领.md) - 了解整体技术决策框架
- [技术分析报告](../../technical-research/current/technical-analysis.md) - 详细的技术调研支撑决策
- [实施路线图](../roadmaps/implementation-roadmap.md) - 决策在实施中的应用